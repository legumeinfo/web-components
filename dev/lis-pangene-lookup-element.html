<!DOCTYPE html>

<html>

  <head>
    <meta charset="utf-8" />
    <title>LIS Web-Components - &lt;lis-pangene-lookup-element&gt;</title>
    <!-- CSS framework -->
    <link rel="stylesheet" type="text/css" href="../node_modules/uikit/dist/css/uikit.min.css">
    <script src="../node_modules/uikit/dist/js/uikit.min.js"></script>
    <!-- web components polyfills -->
    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/lit/polyfill-support.js"></script>
    <!-- GraphQL -->
    <script type="text/javascript" src="./graphql.js"></script>
    <!-- web components -->
    <script type="module" src="../lib/index.js"></script>
  </head>

  <body>

    <div class="uk-container uk-margin-bottom">
      <h1>&lt;lis-pangene-lookup-element&gt;</h1>
      <p>
        The <code>&lt;lis-pangene-lookup-element&gt;</code> provides a form for performing pangene lookups and displays the results in a paginated view.
        The lookup is performed using an external function provided to the component when it is added to the page.
        In this example, the component performs a lookup for legume genes using the LIS GraphQL API query <code>genes</code>.
        The form's genus, species, strain, assembly, and annotation selectors are also populated from this API.
        See the source code for details.
        Note that the form's input and page values are kept up to date in the URL query string parameters.
        This allows users to share specific pages from a lookup via the URL and for the lookup history to be navigated via the Web browser's forward and back buttons.
        If the query string parameters are present when the component loads then a lookup will be automatically performed with the query string parameter values.
      </p>
      <p>
        Optionally, all lookups can be limited to a specific genus by setting the <code>genus</code> attribute/property.
        This will cause the genus field of the lookup form to be automatically set and disabled so that users cannot change it.
        Similarly, all lookups can be limited to a specific species/strain/assembly/annotation by setting the <code>species</code>/<code>strain</code>/<code>assembly</code>/<code>annotation</code> attribute/property.
        You can try setting these properties in this example using the <code>pangeneLookupElement</code> variable in the Web console.
      </p>
      <p>
        Example text for the Gene Identifiers form field can be provided by setting the <code>genesExample</code> attribute/property.
      </p>
      <hr>
    </div>

    <div class="uk-container uk-container-expand">
      <!-- the custom pangene lookup element -->
      <lis-pangene-lookup-element id="pangene-lookup" genesExample="glycy.G1267.gnm1.ann1.Gcy10g023815 glycy.G1267.gnm1.ann1.Gcy10g023812"></lis-pangene-lookup-element>
    </div>

    <!-- set the lookup function by property because functions can't be set as attributes -->
    <script type="text/javascript">

      // uses the LIS GraphQL API to get data used to construct the pangene lookup form
      const formDataQuery = `
      query FormDataQuery {
        chromosomes {
          results {
            annotationVersion
            assemblyVersion
            strain {
              organism {
                genus
                species
              }
              identifier
            }
          }
        }
      }
      `;

    function nextBin(bin, key, defaultValue) {
      if (!(key in bin)) {
        bin[key] = defaultValue;
      }
      return bin[key];
    }

    function getFormData({abortSignal}) {
        return graphqlQuery(uri, formDataQuery, {}, abortSignal)
          .then(({data}) => {
            // bin the strains by genus then species
            const binnedFormData = {};
            data.chromosomes.results.forEach(({
              annotationVersion,
              assemblyVersion,
              strain: {
                organism: {
                  genus,
                  species,
                },
                identifier,
              },
            }) => {
              let bin = binnedFormData;
              bin = nextBin(bin, genus, {});
              bin = nextBin(bin, species, {});
              bin = nextBin(bin, identifier, {});
              bin = nextBin(bin, assemblyVersion, []);
              if (annotationVersion != null) {
                bin.push(annotationVersion);
              }
            });
            // collapse the bins into arrays of objects
            const genuses =
            Object.entries(binnedFormData).map(([genus, binnedSpecies]) => {
              const species =
              Object.entries(binnedSpecies).map(([species, binnedStrains]) => {
                const strains =
                Object.entries(binnedStrains).map(([strain, binnedAssemblies]) => {
                  const assemblies =
                  Object.entries(binnedAssemblies).map(([assembly, annotations]) => {
                    return {
                      assembly,
                      annotations: [...new Set(annotations)]
                        .map((annotation) => {annotation}),
                    };
                  });
                  return {strain, assemblies};
                });
                return {species, strains};
              });
              return {genus, species};
            });
            // return the expected form data object
            return {genuses};
          });
      }

      // pangene lookup query for the LIS GraphQL API
      const pangenesQuery = `
      query PangenesQuery($identifier: ID!, $genus: String, $species: String, $strain: String, $assembly: String, $annotation: String) {
        gene(identifier: $identifier) {
          results {
            identifier
            panGeneSets {
              identifier,
              genes(genus: $genus, species: $species, strain: $strain, assembly: $assembly, annotation: $annotation) {
                identifier
              }
            }
          }
        }
      }
      `;
      
      // the search function given to the LIS gene search Web Component
      function getPangenes(lookupData, page, {abortSignal}) {
        const genus = lookupData['genus'];
        const species = lookupData['species'];
        const strain = lookupData['strain'];
        const assembly = lookupData['assembly'];
        const annotation = lookupData['annotation'];
        const genes = lookupData['genes'].trim().split(/\s+/);
        const variables = {
          genus,
          species,
          strain,
          assembly,
          annotation,
        };

        // shim the results for the Web Component
        return Promise.all(genes.map((identifier) => {
          return graphqlQuery(uri, pangenesQuery, {identifier, ...variables}, abortSignal)
            .then(({data, errors: errorObjects = []}) => {
              const errors = errorObjects.map((error) => error.message);
              if (data.gene == null) {
                return {results: [], errors};
              }
              const {identifier: input, panGeneSets} = data.gene.results;
              // flatten results
              const results = panGeneSets.map(({identifier: panGeneSet, genes}) => {
                return genes.map(({identifier: target}) => {
                  return {input, panGeneSet, target};
                }).filter(({input, panGeneSet, target}) => input != target);
              }).flat();
              if (!results.length) {
                results.push({input, panGeneSet: null, target: null});
                errors.push(`No results found for '${identifier}'`);
              }
              return {results, errors};
            });
        }))
        .then((resultArrays) => {
          const results = resultArrays.map(({results}) => results).flat();
          const errors = resultArrays.map(({errors}) => errors).flat();
          // construct the expected paginated results object
          return {
              hasNext: false,
              numResults: results.length,
              pageSize: results.length,
              numPages: 1,
              results,
              errors,
            };
        });
      }

      // bind component properties
      const pangeneLookupElement = document.getElementById('pangene-lookup');
      pangeneLookupElement.formDataFunction = getFormData;
      pangeneLookupElement.searchFunction = getPangenes;

    </script>

  </body>

</html>
